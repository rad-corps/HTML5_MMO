<!doctype html>
<html>
  <head>
    <title>HULK CHAT!</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font: 13px Helvetica, Arial; }
      form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }
      form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
      form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
      #messages { list-style-type: none; margin: 0; padding: 0; }
      #messages li { padding: 5px 10px; }
      #messages li:nth-child(odd) { background: #eee; }
    </style>
  </head>
  <body>

    <ul id="messages"></ul>
    <form action="">
      <input id="m" autocomplete="off" /><button>Send</button>
    </form>

    <!-- canvas will be injected into this div -->
    <div id="loader" class="layer"></div>

    <!-- TODO, load socket.io.js locally -->
    <script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
    
    <!-- pixi is the canvas rendering engine -->
    <script src="./bin/pixi.min.js"></script>

    <!--jquery-->
    <script src="./bin/jquery-2.1.4.min.js"></script>
    
    <!--register send and receive events -->
    <script>
      var socket = io();
      
      //send player position
      function sendPlayerPos(x_,y_) {
        //create string
        var posStr = x_ + ',' + y_;
        socket.emit('player pos', posStr);
      }

      //receive player position
      socket.on('player pos', function(pos_){
        //split into x and y
        var pos = pos_.split(',');

        //move player according to x and y
        if ( !(pos[2] in window.gameLoop.players ) ) //if key does not exist. create it
        {
          var player = new Player(pos[2]);
          window.gameLoop.players[pos[2]] = (player);
          player.addToStage(window.gameLoop.stage);
        }
                
        window.gameLoop.players[pos[2]].sprite.destination._x = parseInt(pos[0]);
        window.gameLoop.players[pos[2]].sprite.destination._y = parseInt(pos[1]);
        
      });      

      //send chat message
      $('form').submit(function(){
        socket.emit('chat message', $('#m').val());
        $('#m').val('');
        return false;
      });

      //receive chat message
      socket.on('chat message', function(msg){
        $('#messages').append($('<li>').text(msg));
      });
    </script>


    <script>

    var scoreFontStyle = {
      align: 'center',
      font : '20px Arial bold italic',
      fill : '#F7EDCA',
      stroke : '#4a1850',
      strokeThickness : 1,
      dropShadow : true,
      dropShadowColor : '#000000',
      dropShadowAngle : Math.PI / 6,
      dropShadowDistance : 2,
      wordWrap : true,
      wordWrapWidth : 440
};

var vector2 = {
  _x: 1,
  _y: 0,

  create: function(x, y) {
    var obj = Object.create(this);
    obj.setX(x);
    obj.setY(y);
    return obj;
  },

  setX: function(value) {
    this._x = value;
  },

  getX: function() {
    return this._x;
  },

  setY: function(value) {
    this._y = value;
  },

  getY: function() {
    return this._y;
  },

  setAngle: function(angle) {
    var length = this.getLength();
    this._x = Math.cos(angle) * length;
    this._y = Math.sin(angle) * length;
  },

  getAngle: function() {
    return Math.atan2(this._y, this._x);
  },

  setLength: function(length) {
    var angle = this.getAngle();
    this._x = Math.cos(angle) * length;
    this._y = Math.sin(angle) * length;
  },

  getLength: function() {
    return Math.sqrt(this._x * this._x + this._y * this._y);
  },

  add: function(v2) {
   return vector2.create(this._x + v2.getX(), this._y + v2.getY());
  },

  subtract: function(v2) {
   return vector2.create(this._x - v2.getX(), this._y - v2.getY());
  },

  multiply: function(val) {
   return vector2.create(this._x * val, this._y * val);
  },

  divide: function(val) {
   return vector2.create(this._x / val, this._y / val);
  },

  addTo: function(v2) {
    this._x += v2.getX();
    this._y += v2.getY();
  },

  subtractFrom: function(v2) {
    this._x -= v2.getX();
    this._y -= v2.getY();
  },

  multiplyBy: function(val) {
    this._x *= val;
    this._y *= val;
  },

  divideBy: function(val) {
    this._x /= val;
    this._y /= val;
  },

  normalise: function() {
    var mag = this.getLength();
    this._x /= mag;
    this._y /= mag; 
  },

  toString: function(){
    return 'x: ' + this._x + '\ty: ' + this._y;
  }
};

function Player(id_)
{
  var self = this;
  self.id = id_;
  self.sprite = PIXI.Sprite.fromImage("./img/player.png");
  self.sprite.position.set(400,300);
  self.sprite.destination = vector2.create(300, 200);

  //socket id @ (only for testing)
  //socket.io.engine.id
  self.socketText = new PIXI.Text(self.id, scoreFontStyle);

  self.addToStage = function(stage_)
  {
    stage_.addChild(self.sprite);
    stage_.addChild(self.socketText);
  }

  self.update = function()
  {
    self.socketText.position.set(self.sprite.position.x - 100, self.sprite.position.y - 20);
  }
}

    function GameLoop()
    {
      console.log('GameLoop constructor');
      var self = this;

      //update loop
      self.animate = function()
      {
        //move player towards destination
        for ( p in self.players )
        {
          var position = vector2.create(self.players[p].sprite.position.x, self.players[p].sprite.position.y);
          //console.log('position1' + position.toString() );
          var direction = self.players[p].sprite.destination.subtract(position);
          direction.normalise();
          position.addTo(direction);
          //console.log('position2' + position.toString() );

          self.players[p].sprite.position.x = position._x;
          self.players[p].sprite.position.y = position._y;
          self.players[p].update();
        }        

        //render then ask for another animation frame
        self.renderer.render(self.stage);    
        requestAnimationFrame(self.animate);
      }

      //create the renderer 
      self.renderer = new PIXI.WebGLRenderer(800, 600);//autoDetectRenderer(800, 600);

      //add it to the DOM body
      document.body.appendChild(self.renderer.view);

      //create a stage (all sprites added to this)
      self.stage = new PIXI.Container();

      //mouse and touch event for the bg sprite
      self.backgroundMouseDown = function(event_) {
        //send the data to the server
        sendPlayerPos(event_.data.global.x, event_.data.global.y);
      }

      //create a background sprite
      self.bgSprite = PIXI.Sprite.fromImage("./img/bg.jpg");
      self.bgSprite.position.set(0,0);
      self.bgSprite.interactive = true;

      //register mouse and touch events for the bg sprite
      self.bgSprite.on('mousedown', self.backgroundMouseDown);
      self.bgSprite.on('touchstart', self.backgroundMouseDown);

      self.stage.addChild(self.bgSprite);

      //create a player sprite and pop him in the middle
      self.players = [];
      self.players[socket.io.engine.id] = new Player(socket.io.engine.id);
      self.players[socket.io.engine.id].addToStage(self.stage);

      requestAnimationFrame( this.animate );
    }

    function onAssetsLoaded(){
      window.gameLoop = new GameLoop();
      //window.gameLoop.init();
      //window.gameLoop.run();
      //startGame();
      //document.getElementById("loader").style.display = "none";
    }

    function preloadTextures() {
      
      // create a new loader
      var loader = PIXI.loader;
      loader.add('player', "./img/player.png");
      loader.add('bg', './img/bg.jpg');
      // use callback
      loader.once('complete', onAssetsLoaded);
      //begin load
      loader.load();
    }

    preloadTextures();
    </script>




  </body>
</html>

